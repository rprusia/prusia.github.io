
# What is XPATH
XPath uses path expressions to select nodes or node-sets in an XML document.

These path expressions look very much like the path expressions you use with traditional computer file systems

# Nodes
In XPath, there are seven kinds of nodes: element, attribute, text, namespace, processing-instruction, comment, and document nodes.

```
<bookstore>
  <book>
    <title lang="en">Crime and Punishment</title>
    <author>Fyodor Dostoyevsky</author>
    <year>1866</year>
    <price>19.99</price>
  </book>
</bookstore>
```

### Relationship of Nodes
* Parent Nodes: Each element and attribute has one parent.
* Chidren Nodes:  Element nodes may have zero, one or more children.
* Sibling Nodes:  nodes that have the same parent are siblings
* Ancestors:   **Title** has ancestors of **book** and **bookstore**
```
   <bookstore>
     <book>
       <title lang="en">Crime and Punishment</title>
       <author>Fyodor Dostoyevsky</author>
       <year>1866</year>
       <price>19.99</price>
     </book>
   </bookstore>

   ```


#Xpath Examples:

```
Expression	Description
nodename	Selects all nodes with the name "nodename"
/	        Selects from the root node
//	Selects nodes in the document from the current node that match the selection no matter where they are
.	Selects the current node
..	Selects the parent of the current node
@	Selects attributes

Path Expression	Result
bookstore	Selects all nodes with the name "bookstore"
/bookstore	Selects the root element bookstore
Note: If the path starts with a slash ( / ) it always represents an absolute path to an element!

bookstore/book	Selects all book elements that are children of bookstore
//book	Selects all book elements no matter where they are in the document
bookstore//book	Selects all book elements that are descendant of the bookstore element, no matter where they are under the bookstore element
//@lang	Selects all attributes that are named lang

```

###	Abosolute Xpath (NOT RECOMMENDED)
* Has performance issues, not reliable, can be changed in future (brittle)
* //*[@id=’headsearch’]/div/div[2]/table/tbody/tr/td[2]/input

### Find by TEXT value
* //a[text()='Features']
* //a[contains(text(),'Features']
* //button[contains(text(),'Sign up')]

### Finds button using conditional *AND*
* //button[@type='button' and @class='btn']

### Finds input by attribute using @
* //input[@lightning-input_input='search']

### Find using contains
* //a[contains(text(),'AccountContactRelations/view')]
* //span[contains(text(),'Related Contacts')]
* //a[contains(text(),'/related/AccountContactRelations/view')]


### Starts-with
The following will locate id using substring starts-with:
* id = test-343
* id = test-494
* Example:   //input[starts-with(@id,'test_')]

### Ends-with 
The following will locate id using substring ends-with:
* id = 12230_test-t
* id = 13_test-t
* //input[ends-with(@id,'_test_')]


### How to find number of a particular element on page
```
List <WebElement> linklist = driver.findElements(By.tagName(“a”));
System.out.println(linklist.size)  // print number of anchors <a>

for (int i= 0 ; I < linklist.size; i++ )
{
	String linkText = linklist.get(i).getText();
	System.out.println(linkText)  // print out text of each link.
}
```
